# Stepik.-Easy_Start_In_Java.-IntroductoryCourse_forDummies

## Теория

### 2 Базовые понятия.

#### Структура программы на Java

Традиционно первая программа в любом курсе - это код, выводящий на экран приветствие **"Hello, World!"**.

Давайте сделаем это ;)

 ```

class MyClass {
    public static void main(String[] args) {
        System.out.println("Hello World");
    }
}
 ```
Выглядит довольно сложно, однако сейчас нет необходимости подробно разбираться с назначением каждой команды в этом коде. Отметим только самое важное.

Программа на **Java** - это совокупность объектов, которые взаимодействуют через вызов друг друга. Таким образом, на практике программа состоит из большого количества файлов с расширением **.java**, расположенных в каталоге программы.

Каждый файл представляет собой отдельный класс. Наименование класса должно начинаться с заглавной буквы и строго совпадать с названием файла.

Если посмотреть на пример выше, то, чтобы запустить его на компьютере, а не в песочнице Степик, нужно поместить код в файл с именем **MyClass.java.** Так как наша программа простая, она будет состоять всего из одного класса (файла). В больших проектах классов сотни и тысячи.

---

Давайте немного систематизируем. Чтобы терминология была более понятна, рассмотрим простой пример - автомобиль.

1. Класс.

В Java каждая исполняемая строка кода должна находиться внутри определённой группы команд, которая называется классом. Можно сказать, что класс - это шаблон, описывающий поведение объекта. В нашем примере мы назвали класс **MyClass**. Содержимое класса помещается внутри фигурных скобок {}.

В нашем примере с автомобилем класс - это чертёж, то есть, абстрактный образец, по которому можно собрать конкретный автомобиль.  

2. Метод.

Внутри класса у каждой программы есть точка входа, которой является метод, называющийся **main**. Содержимое метода также находится внутри фигурных скобок. В целом, фигурные скобки используются во многих языках программирования для выделения групп команд, функций или методов. Такое выделение может показаться неудобным (особенно тем, кто программирует на Python или подобных языках), однако в реальной разработке может быть гораздо функциональнее, чем другие способы выделения. 

Методы описывают поведение объекта внутри класса. Класс может содержать несколько методов, но главный метод **main** - обязательно..

В нашем примере с автомобилем методы - это действия, которые может выполнять автомобиль, например "ехать вперёд", "открыть дверь", "включить габариты".

3. Объект.

Объект - это экземпляр класса. В нашем примере это готовый конкретный автомобиль. Подобно тому, как по одним и тем же чертежам может быть создано множество автомобилей, внутри класса может быть создано множество объектов класса.

4. Переменные экземпляра.

Переменные экземпляра - это уникальный набор характеристик объекта. Состояние объекта передаётся значениями переменных. Грубо говоря, конкретный автомобиль имеет цвет, размеры, грузоподъёмность, в данный момент времени может ехать, а может стоять и т.д.

 

На данном этапе этого достаточно, более подробно мы рассмотрим этот материал в следующих модулях.

---

#### Метод main

Чтобы наша программа заработала, метод main должен выглядеть в точности так:

```
public static void main(String[] args)
```
Вот значение ключевых слов, используемых в этом выражении. Для тех, кто только приступает к изучению программирования, нижеизложенное может показаться непонятным, в этом случае можно пока пропустить этот шаг.

**public** - это модификатор доступа, означающий, что ограничений на доступ к данному методу нет. В каждом исходном файле может быть только один метод с модификатором **public**.

**static** означает, что метод может работать без образования экземпляра класса. Например, если мы хотим посчитать высоту конкретного здания, то нам понадобится это здание (это и есть экземпляр класса), иначе будет нечего измерять. Если же требуется  вывести на печать фразу **"Hello, World!"**, то ничего такого нам не потребуется.

**void** означает, что метод ничего не возвращает в результате работы. Обратите внимание, что "не возвращает" не значит, что "не выводит" или "ничего не делает"! 

**main** - это имя нашего метода.

Например, следующий код объявляет метод **test**, который ничего не возвращает и не имеет параметров:

```
void test()
```
Параметры метода объявляются в круглых скобках, следующих за именем метода.
Для **main** это массив строк, называемых **args**. Мы будем использовать его в нашем следующем уроке, так что не волнуйтесь, если вы не понимаете всего этого сейчас.

---

#### Вывод на консоль

Вывод на консоль в Java осуществляется командами 
```
System.out.println()
System.out.print()
```
Первая команда после вывода переносит курсор на следующую строку, а вторая нет. Обратите внимание, что команда начинается с большой буквы.

Теперь напишем содержание основного метода main нашей программы, которая должна печатать приветствие:
```
{
   System.out.println("Hello World!");
}
```
Разберём подробно.

**println** - метод, печатающий строку на экране. То, что нужно напечатать, заключается в круглые скобки, следующие после наименования метода.

**System** - это класс, а **out** - поток, используемые для доступа к методу **println**.

Каждая строка кода должна заканчиваться точкой с запятой, а весь код, заключённый в методе (или классе, или других структурах управления) **всегда** помещается внутрь фигурных скобок.

Да, синтаксис Java довольно строг и поначалу непонятен, однако именно эта строгость и последовательность даёт много преимуществ.

Итак, мы подробно разобрали код нашей первой программы-приветствия. Добро пожаловать в Java

---

#### Точка с запятой

Можно передать методу println любой другой текст в качестве параметра и вывести его на печать. Текст помещается в двойные кавычки. Например:
```
class MyClass {
    public static void main(String[] args) {
        System.out.println("Я изучаю Java!");
    }
}
```
выведет :
```
Я изучаю Java!
```
Можно выводить результат выражения, заключённого в скобки метода println. Выведем последовательно несколько слов:
```
System.out.println("Я" + "изучаю" + "Java"); //ЯизучаюJava
System.out.println("Я" + " " + "изучаю" + " " + "Java"); //Я изучаю Java
```
Чтобы текст не сливался, между словами необходимо вставлять пробелы, которые являются такими же символами, что и прочие.

Как уже было отмечено ранее, все операторы кода в обязательном порядке заканчиваются точкой с запятой. Если забыть хоть одну, программа выдаст ошибку(.

Однако важно помнить, что точка с запятой НЕ ставится после структур, помещённых в фигурные скобки. 

---

#### Комментарии

Цель включения комментариев в код состоит в том, чтобы объяснить, что делает код.
**Java** поддерживает как однострочные, так и многострочные комментарии. Все символы, которые появляются в комментарии, игнорируются компилятором **Java**.

Однострочный комментарий начинается с двух косых черт и продолжается до конца строки.
```
// Это однострочный комментарий
x = 5; // Это тоже однострочный комментарий, расположенный после кода
```
Добавление комментариев при написании кода является хорошей практикой, поскольку они дают разъяснения и понимание, когда вам нужно вернуться к нему, а также для других, кому, возможно, потребуется его прочитать.

---

#### Многострочный комментарий

Java также поддерживает комментарии, охватывающие несколько строк.
Вы начинаете этот тип комментария со знака "слэш" (/), за которой следует звездочка, и заканчиваете его звездочкой, за которой следует слэш.
```
/* Это
многострочный
комментарий */
```
Обратите внимание, что Java не поддерживает вложенные многострочные комментарии.
Однако вложить однострочные комментарии в многострочный можно ).
```
/* Это многострочный комментарий.

    // Это однострочный комментарий внутри многострочного.

Не знаю, зачем это нужно, но вдруг пригодится? */
```
В приведённом примере отступы и пустые строки приведены для удобства, а комментарии могут иметь любое форматирование.

---

#### Документационные комментарии (Javadoc)

Комментарии к документации - это специальные комментарии, которые имеют вид многострочных комментариев, с той разницей, что они генерируют внешнюю документацию исходного кода. Они начинаются с прямой косой черты, за которой следуют две звездочки, и заканчиваются звездочкой, за которой следует прямая косая черта. 
```
/** Это документационный комментарий */

/** Это тоже
документационный комментарий */
```
**Javadoc** - это инструмент, который поставляется вместе с JDK и используется для создания документации Java-кода в формате HTML из исходного кода Java, который имеет необходимую документацию в предопределенном формате.

Когда комментарий документации начинается с более чем двух звездочек, Javadoc предполагает, что вы хотите создать "коробку" вокруг комментария в исходном коде. Он просто игнорирует лишние звездочки.

 
```
/*******************

Здесь начало метода 

*********************/
```
При таком оформление во внешнюю документацию попадёт только текст "Здесь начало метода".

---

#### Переменные

Переменные хранят данные для обработки.
Переменной присваивается имя (или идентификатор), например площадь, возраст, рост и т. п. Имя однозначно идентифицирует каждую переменную, присваивая ей значение или извлекая сохраненное значение, когда это нужно.

Переменные имеют типы. Некоторые примеры:


- **int**: для целых чисел, таких как 123 и -456. На самом деле, типов для целых чисел в Java несколько, но об этом поговорим позже.
- **float**  и **double**: для чисел с плавающей запятой или вещественных чисел, таких как 3.1416, -55.66. Эти типы данных имеют определённые различия, но в целом очень похожи. Мы будем использовать **double**. Во всех языках программирования целая часть отделяется от дробной точкой, а не запятой.
- **String**: для таких текстов, как "Привет" или "Доброе утро!". Текстовые строки заключаются в двойные кавычки. Мы уже имели дело с этим типом данных, когда выводили на печать приветствие "Hello, World!".

 

Перед тем, как использовать переменную, её необходимо объявить. Затем можно присвоить какое-нибудь значение.
```
String name;
name = "Ivan";
```
Можно объявить переменную определенного типа и сразу присвоить ей значение.
```
String name = "Ivan";
```
Здесь мы создали переменную, дали ей имя **name**, задали её тип - **String** и присвоили ей значение "Ivan". Если попытаться использовать переменную до того, как она объявлена, программа не скомпилируется (выдаст ошибку).

Важно отметить, что в Java переменная связана с типом и способна хранить только значения этого конкретного типа. Например, переменная int может хранить целочисленные значения, такие как 123; но она не может хранить действительные числа, такие как 12.34, или тексты, такие как "Привет".

---

#### Примеры объявления переменных
```
class MyClass {
    public static void main(String[] args) {
        String name = "Ivan";
        int age = 25;
        double score = 15.9;
        char group = 'Z';
    }
}
```
Тип переменной **char** используется для хранения одного символа. В отличие от строк, значение переменной типа char помещается в одинарные кавычки.

Кроме того, есть ещё один очень важный тип данных - логический (булевый), или **boolean**. Переменные этого типа могут принимать только два значения: **true или false**. 
```
boolean atHome = true;
```
Использование логических переменных необходимо для работы практически любой программы.

Рассмотрим пример. Пусть у нас есть две переменные:
```
int x1 = 100;
int x2 = 90;
```
Мы видим, что одна переменная больше другой, таким образом, выражение x1 > x2 является истинным, а x1 < x2 - ложным.

Результат сравнения можно записать в переменную.
```
int x1 = 100;
int x2 = 90;
boolean f1 = x1 > x2;
boolean f2 = x1 < x2;
```
В приведённом примере значение переменной f1 будет равно true, а значение переменной f2 - false.

 

Также иногда удобно объявлять несколько переменных одного и того же типа в одной строке через запятую:
```
int a = 42, b = 11;
```
Обе объявленные переменные будут иметь целочисленный тип.

 

Чтобы вывести значение переменной на печать, нужно передать её в метод println:
```
int x = 42;
String y = "Значение переменной x равно ";
int z = 58;
System.out.println(x);              // 42
System.out.println(x + z);          // 100
System.out.println("x = " + 42);    // x = 42
System.out.println(y + x);          // Значение переменной x равно 42
System.out.println(y + x + z);      // Значение переменной x равно 4258
System.out.println(y + (x + z));    // Значение переменной x равно 100
```
Внимательно рассмотрите пример. Если мы передаём два числа - метод println их складывает. Если же мы передаём строку и число, выражение автоматически приводится к строчному типу. В то же время, соблюдается обычная очерёдность операций - вначале производятся операции, заключённые в скобки.

Часто бывает нужно вывести значение нескольких переменных в одну строку. Для этого воспользуемся тем же способом и приведём все данные в строковый формат.
```
int x = 42;
int y = 84;
System.out.println(x + " " + y);    // 42 84
```

---

#### Ввод данных в программу

В то время как Java предоставляет множество различных методов для пользовательского ввода, объект Scanner является наиболее распространенным и, возможно, самым простым в реализации. Импортируйте класс **Scanner** для использования объекта **Scanner**, как показано здесь:
```
import java.util.Scanner; 
```
Чтобы использовать класс Scanner, создайте экземпляр класса, используя следующий синтаксис:
```
Scanner sc = new Scanner(System.in);
```
Теперь вы можете читать различные виды входных данных, которые вводите. При этом имя объекта можно задать произвольно (не обязательно sc).
Вот некоторые методы, доступные через класс Scanner:


Ввести объект int: **nextInt()**
Ввести объект float: **nextFloat()**
Ввести объект double: **nextDouble()**
Ввести объект boolean: **nextBoolean()**
Ввести строку целиком: **nextLine()**
Ввести слово (считывается до первого пробела): **next()**

Пример программы, используемой для получения пользовательского ввода:
```
import java.util.Scanner;

class MyClass {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.println(sc.nextLine());
    }
}
```
Эта программа  будет ждать, пока пользователь введет что-то, а затем выведет на печать полученную строку. Работает она следующим образом: сначала мы инициируем новый экземпляр класса Scanner и присваиваем ему имя sc. Затем даём задание этому экземпляру считать строку командой sc.nextLine(), после чего полученная строка поступает на поток вывода. 

Чтобы получить несколько объектов данных с входящего потока, достаточно одного объекта сканера. Единственный сканер может обрабатывать входные данные различных типов:
```
import java.util.Scanner;

class MyClass {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int x = sc.nextInt();
        double y = sc.nextDouble();
        String s = sc.nextLine();
    }
}
 ```

После использования сканер желательно закрыть командой **sc.close()**. На потоке System.in незакрытый сканер чаще всего ни на что не влияет, однако, в реальной практике, при работе с другими потоками (файл, драйвер, сетевой ресурс и т.д.) незакрытый сканер может привести к утечке памяти. 


Код может показаться сложным, но далее мы будем разбирать всё более подробно.

---

#### Математические операторы

Java предоставляет широкий набор операторов для работы с переменными. Значение, используемое по обе стороны от оператора, называется операндом.
Например, в приведенном ниже выражении числа 6 и 3 являются операндами оператора сложения:
```
int x = 6 + 3;
```
Основные арифметические операторы:

- \+	Сложение
- \-	Вычитание
- \*	Умножение
- /	Деление                   
- %	Остаток от деления               
Использование арифметических операторов в Java  идентично их использованию в алгебраических выражениях.

---

**Сложение**

Оператор сложения **+** складывает вместе два значения, например, две константы, константу и переменную или переменную и переменную. Вот несколько примеров сложения:
```
int sum1 = 50 + 10; 
int sum2 = sum1 + 66; 
int sum3 = sum2 + sum2;
```
**Вычитание**

Аналогичным образом, оператор вычитания - вычитает один операнд из другого:
```
int sum1 = 1000 - 10;
int sum2 = sum1 - 5;
int sum3 = sum1 - sum2;
```
---
**Умножение и деление**

Умножение:
```
int num1 = 1000 * 2;
int num2 = num1 * 10;
int num3 = num1 * num2;
```
Деление:
```
int num1 = 1000 / 5;
int num2 = num1 / 2;
int num3 = num1 / num2;
```
Если умножение и деление производятся с данными целочисленного типа. то и результат будет целочисленным, а в случае работы с числами с плавающей точкой (float или double) - результат также будет числом с плавающей точкой. 

В том случае, если одно из чисел будет целочисленного типа, а второе - числом с плавающей точкой, то результат также будет числом с плавающей точкой. Это особенно важно в случае деления:

- если мы делим одно число типа int на другое, также типа int, то это будет **целочисленное деление**. К примеру, если разделить 15 на 4, результатом будет 3.

- если одно или оба числа имеют тип float или double, то результатом будет число с плавающей точкой:
```
15 / 4 = 3;
15.0 / 4 = 3.75;
15 / 4.0 = 3.75;
15.0 / 4.0 = 3.75;

15 / 3 = 5;
15.0 / 3 = 5.0;
15 / 3.0 = 5.0;
```

---

#### Остаток от деления

Математическая операция **modulo** выполняет целочисленное деление одного значения на другое и возвращает остаток от этого деления.
Оператор этой операции - символ процента ( % ).
```
int myVar = 37;
int res = myVar % 5; // res = 2
```
В примере мы делим 37 на 5. Остаток от этого деления составляет 2, это значение присваивается переменной res.

 

**Сокращённая запись арифметических операторов**

Для экономии времени предусмотрена сокращённая запись арифметических операторов.
```
x += y;    // То же самое, что и x = x + y;
x -= y;    // То же самое, что и x = x - y;
x *= y;    // То же самое, что и x = x * y;
x /= y;    // То же самое, что и x = x / y;
x %= y;    // То же самое, что и x = x % y;
```

---

#### Инкремент

Оператор, называемый **инкрементом**, представляет собой удобный и компактный способ увеличения значения переменной на единицу. Соответственно, оператор **декремента** уменьшает значение переменной на единицу. Инкремент записывается с помощью двух последовательных плюсов (++), а декремент - с помощью двух последовательных минусов (--).

Примеры:
```
int test = 5;
++test; // test == 6

int test = 5;
--test; // test == 4
```
Использовать эти операторы необходимо, чётко понимая механизм их работы.

---

**Префикс и постфикс**

Существуют две формы использования инкремента (декремента) - префиксная и постфиксная.
В префиксной форме оператор появляется перед операндом, в то время как в постфиксной форме оператор появляется после операнда. Давайте разберёмся, как работают эти две формы.
**Префикс**: инкремент увеличивает значение переменной и использует новое значение в выражении.
```
int x = 50;
int y = ++x; // x == 51, y == 51
```
В этом примере значение переменной **х** **сначала увеличивается** на единицу с помощью инкремента, а затем это (уже увеличенное) значение присваивается переменной **y**.

**Постфикс**: значение переменной **сначала используется** в выражении, а уже потом увеличивается на единицу. 
```
int x = 50;
int y = x++; // x == 51, y == 50
```
Точно так же работает и декремент.

---

#### Оператор присваивания

Мы уже использовали оператор присваивания (=), который присваивает переменной определённое значение.
```
int value = 5;
```
В Java, как и во многих других языках программирования, есть инструменты, помогающие сократить и упростить код. К примеру, оператор **+=** присваивает переменной сразу увеличенное значение.
```
int x = 4;
x += 1; // x == 5

int x = 4;
x += 2; // x == 6

int x = 4;
int y = 5;
x += y; // x == 9
```
Точно так же работают и другие подобные операторы:

-=	Вычитание и присвоение
*=	Умножение и присвоение
/=	Деление и присвоение
%=	Остаток от деления и присвоение

---

#### Строки

Строка - это объект, представляющий последовательность символов. Базовый класс для строк - это String.
Например, "Hello" - это строка из 5 символов. При присвоении переменной значение указывается в двойных кавычках:
```
String s = "Я изучаю Java"; 
```
Здесь мы декларируем переменную s типа String и присваиваем ей значение "Я изучаю Java".

Можно задать пустую строку:
```
String str = "";
```
Строка в Java является неизменяемым типом. То есть, чтобы изменить переменную типа String, нужно создать новый объект, а старый при этом уничтожается. Для работы со строками, которые всё же нужно менять, существуют дополнительные классы, такие, как **StringBuilder**. Такое видимое неудобство компенсируется повышением скорости обработки тех строк, которые не нужно менять.

Количество символов в строке называется её длиной. Индексация (нумерация) начинается с 0. 

---

#### Конкатенация

В большинстве языков программирования складывать можно не только числа, но и строки. Сложение строк называется конкатенацией. В результате конкатенации получается также строка: это первая строка, соединенная со второй строкой.
```
String firstWord, secondWord;
firstWord = "Hello";
secondWord = "World";
System.out.println(firstWord + secondWord); //HelloWorld
```

Этот код выведет на печать **HelloWorld**. Обратите внимание, что пробел также является значимым символом в строке. Таким образом, если мы хотим получить нормальное читаемое приветствие, нужно немного изменить код, например, вот так:
```
String firstWord, secondWord;
firstWord = "Hello";
secondWord = "World";
System.out.println(firstWord + " " + secondWord + "!"); //Hello World!
```
---

#### Методы строк

Класс String имеет множество встроенных методов для обработки строк. Разберём некоторые из них.

Общий синтаксис для всех методов выглядит так:
```
stringName.nameOfMethod();
```
Здесь метод nameOfMethod применяется к строке stringName и вызывается с помощью круглых скобок. Внутри круглых скобок в некоторых методах должны быть обязательные аргументы, а в некоторых других - нет.

1. Длина строки (количество символов).
```
str.length();      // возвращает длину строки str (количество символов, включая пробелы)

String word = "Java is strong";
int x = word.length();
System.out.println(x); // 14
```

2. Сравнение строк.

В Java строки нельзя сравнивать с помощью операторов сравнения, таких как == и !=. Вернее, сравнивать-то можно, но результат Вас удивит ;) Для корректного сравнения строк необходимо использовать специальный метод:
```
str1.equals(str2); // Сравнивает строки str1 и str2
```
Этот метод является булевым, то есть возвращает true, если строки равны, и false, если нет.
```
String word1 = "Java";
String word2 = "Python";
System.out.println(word1.equals(word2)); // false

String word3 = "Ja";
String word4 = "va";
boolean result = word1.equals(word3 + word4); 
System.out.println(result); // true
``` 

3. Получение индекса элемента в строке.

Метод **indexOf()** ищет в строке заданный символ (или строку), и возвращает  индекс его первого вхождения. Если элемент не найден, метод возвращает -1.
```
String word = "abracadabra";
int x = word.indexOf('b');
System.out.println(x); // 1

int y = word.indexOf('Z');
System.out.println(y); // -1
``` 

4. Получение элемента строки по его индексу.

Для этого используется метод **charAt()**:
```
String word = "abracadabra";

char letter_0 = word.charAt(0);
System.out.println(letter_0); // a

char letter_4 = word.charAt(4);
System.out.println(letter_4); // c
```
Обратите внимание - метод возвращает значение типа char, а не String. Индексация, как обычно, начинается с нуля.

 

5. Проверка строки на пустоту.

Метод **isEmpty()** является весьма полезным инструментом. Он возвращает false, если строка содержит какие-либо элементы (пробел - тоже элемент), и true - если строка пустая, т.е. не содержит ни одного элемента.
```
String str1 = "Hubba Bubba";
String str2 = "   ";
String str3 = "";

boolean value1 = str1.isEmpty(); // false
boolean value2 = str2.isEmpty(); // false
boolean value3 = str3.isEmpty(); // true
```

6. Одна строка внутри другой

Чрезвычайно полезный метод **contains()** проверяет, содержится ли одна строка внутри другой, и возвращает соответствующее логическое значение - true или false.
```
String str1 = "One Two Three";
String str2 = "One";
String str3 = "Four";

boolean value1 = str1.contains(str2); // true
boolean value1 = str1.contains(str3); // false
```

7. Преобразование регистров.

Методы  **toUpperCase() / toLowerCase()** приводят всю строку в верхний и нижний регистр соответственно.
```
String s = "I'll be back";

System.out.println(s.toLowerCase()); // i'll be back
System.out.println(s.toUpperCase()); // I'LL BE BACK
``` 

8. Представление числа в строковом формате.

Иногда полезно работать не с числом, а с его представлением в виде строки. Для этого Java предоставляет метод **toString()**. Чтобы использовать этот метод, нужно воспользоваться классом - обёрткой **Integer**. Сделать это можно разными путями.
```
int n = 12345;                      // Это число типа int
System.out.println(n);              // 12345 

String str1 = Integer.toString(n);  // Это строка
System.out.println(str1);           // 12345

Integer num = n;                    // Это число-объект класса Integer
System.out.println(num);            // 12345

String str2 = num.toString();        // Это строка
System.out.println(str2);            // 12345
 
```
На самом деле, метод toString является мощным инструментом, который широко используется, однако мы пока ограничимся небольшой частью его функционала.

 

9. Преобразование строки в число.

Метод, обратный предыдущему - **valueOf()** преобразует строку в число нужного типа.
```
String str = "12345";
Integer num = Integer.valueOf(str);  // num - объект класса Integer
System.out.println(num);             // 12345

int num1 = num;                      // num1 - переменная типа int
System.out.println(num1);            // 12345
```
Поскольку оба метода (toString() и valueOf()) - это методы класса Integer, то именно с объектами этого класса их и необходимо использовать. Подробнее о типах переменных и их взаимоотношениях мы коснёмся в следующих модулях.

Есть и ещё один, более простой метод преобразования строки в число - **parseInt()**, также принадлежащий классу Integer.
```
String str = "12345";

int num = Integer.parseInt(str);    //num - переменная типа int
System.out.println(num);            //12345
```
Если нужно преобразовать строку в число с плавающей точкой, можно использовать соответствующий метод из класса Double.
```
String str = "12345";

double num = Double.parseDouble(str);    //num - переменная типа double
System.out.println(num);                 //12345.0
``` 

10. Создание подстроки.

Метод substring() возвращает новую строку, которая является подстрокой данной строки. Подстрока начинается с символа, заданного индексом, и продолжается до конца данной строки или до указанного индекса.
```
String str = "Добро пожаловать в мир Java!";

System.out.println(str.substring(6));         //пожаловать в мир Java!

System.out.println(str.substring(6, 15));     //пожаловат
``` 

11. Замена элементов строки.

Несмотря на то, что строки в Java являются неизменяемыми (immutable), всё-таки их можно изменять с помощью специального метода **replace()**, который может заменить один символ на другой. Этот метод не изменяет строку, а собирает новую по заданным параметрам. Метод принимает два обязательных параметра - символ, подлежащий замене, и символ, на который его нужно заменить.
```
String str = "Добро пожаловать в мир Java!";

System.out.println(str.replace('о', 'А')); //ДАбрА пАжалАвать в мир Java!
```
Обратите внимание - метод работает с заменой символов (char), о чём говорят одинарные кавычки.

 

Дополнительно методы строк можно поизучать в [официальной документации](https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/String.html).

---

#### Выведение на печать нескольких переменных

Java позволяет выводить на печать несколько переменных одновременно. Например, нужно вывести на печать значение переменной x, сопровождаемое текстом "Результат вычислений равен". Можно сделать так:
```
int x = 42;

System.out.print("Результат вычислений равен ");
System.out.print(x);

// Результат вычислений равен 42
```

Для  упрощения можно использовать конкатенацию (сложение) строк. В этом случае все выводимые переменные перечисляются через знак сложения.
```
int x = 42;
System.out.println("Результат вычислений равен " + x);

//Результат вычислений равен 42
```
При обработке такого выражения все переменные, находящиеся после первого значения типа String, будут автоматически преобразованы в строку. Обращайте внимание на порядок аргументов:
```
int x = 10, y = 15;

System.out.println(x + 1 + " не равно " + y);   //11 не равно 15
System.out.println(x + " не равно " + y + 1);   //10 не равно 151
System.out.println(x + " не равно " + (y + 1)); //10 не равно 16
```
В последней строке выражение у + 1 заключено в скобки, поэтому имеет высший приоритет исполнения. Сначала вычисляется результат сложения, и лишь затем происходит приведение к строчному типу.

---

### 3 Условные конструкции

#### Принятие решений

**Условные операторы** используются для выполнения различных действий в зависимости от того, выполняется ли какое-либо условие. 

**Условие** - это выражение, принимающее логическое значение true или false.


Оператор **if** является одним из наиболее часто используемых условных операторов. Если выражение условия оператора if истинно (имеет значение true), то выполняется блок кода внутри оператора if. Если выражение оказывается ложным, выполняется первый набор кода после окончания оператора if (после закрывающей фигурной скобки).

Синтаксис:
```
if (условие) {
   //блок команд
}
```

Обратите внимание, что условие должно быть заключено в круглые скобки, а выполняемый блок команд - в фигурные.  Каждая строка внутри блока команд должна заканчиваться точкой с запятой.

Внутри условия можно использовать операторы сравнения:          
         
<	меньше       
\>	больше       
==	равно       
!=	не равно         
<=	меньше или равно         
\>=	больше или равно         
Пример:
```
int x = 7;
if (x < 42) {
    System.out.println("Меньше");
}
```

Частая ошибка, которую допускают новички - использование одного знака равенства вместо двух, что приводит к некорректной работе кода. Необходимо помнить, что один знак равенства - это оператор присваивания.

---

#### Альтернативные конструкции

За оператором **if** может следовать необязательный оператор **else**, который выполняется, когда условие ложно (имеет значение false).
```
int month = 10;
if (month <= 6) {
    System.out.println("Первая половина года");
} else {
    System.out.println("Вторая половина года");
}
```
Поскольку значение переменной month больше, чем 6, выполнится блок команд, расположенный после ключевого слова else/

---

#### Тернарный оператор

Тернарный оператор - это краткая альтернатива конструкции if/else. К примеру, мы хотим проверить число на чётность, и вывести на печать соответствующий ответ.
```
int x = 24;

if (x % 2 == 0) {
    System.out.println("Число чётное");
} else {
    System.out.println("Число нечётное");
}

// Число чётное
```
С помощью тернарного оператора этот код можно уместить в одну строку.
```
int x = 15;

System.out.println((x % 2 == 0) ? "Число чётное" : "Число нечётное");
```
Вопросительный знак заменяет слово "if" и проверяет условие на истинность. В случае, если условие истинно, выполняется выражение, следующее после вопросительного знака, а если ложно - исполняется выражение после двоеточия, которое заменяет слово "else".

Использовать тернарный оператор рекомендуется, если проверяемое условие не очень сложное. Использование тернарного оператора в запутанных логических конструкциях делает код нечитабельным и, как следствие, плохим.

---

#### Логические операторы

Логические операторы используются для объединения нескольких условий.

Допустим, вы хотите, чтобы ваша программа выводила "Добро пожаловать!" только тогда, когда возраст человека больше 18 лет, а количество решёных задач больше 500.
Один из способов сделать это-использовать вложенные операторы if:
```
if (age > 18) {
    if (tasks > 500) {
        System.out.println("Добро пожаловать!");
    }
}
```
Однако, использование логического оператора "И" позволяет сделать код более коротким и читаемым. В Java логическое "И" - это оператор &&.
```
if (age > 18 && tasks > 500) {
    System.out.println("Добро пожаловать!");
}

```
В примере использованы два логических условия (age > 18  и tasks > 500), и вся логическая конструкция будет иметь значение true только в том случае, если каждое из условий будет иметь значение true. Если хотя бы одно из условий примет значение false, то и вся конструкция примет значение false.

---

#### Логическое ИЛИ, логическое НЕ

Наряду с логическим И также широко используется оператор логическое ИЛИ (||).

Этот оператор проверяет, верно ли какое-либо из условий.
Логическая конструкция  становится истинной, если хотя бы одно из условий имеет значение true.
```
int age = 25;
int tasks = 100;

if (age > 18 || tasks > 500) {
    System.out.println("Добро пожаловать!");
}
```
Этот код выведет на печать приветствие "Добро пожаловать!", так как одно из условий (age > 18) имеет значение true.

Логическое НЕ (!) используется для изменения логического состояния своего операнда. Если условие истинно, то логическое НЕ сделает его ложным (и наоборот). Мы уже сталкивались с примером использования логического НЕ как составной части оператора арифметического неравенства (!=).
```
int age = 25;

if (!(age > 17)) {
    System.out.println("Вы несовершеннолетний");
} else {
    System.out.println("Добро пожаловать!");
}
```
Обратите внимание: логическая конструкция НЕ (x > y) эквивалентна x <= y, то есть, знак неравенства меняется на противоположный, и, вдобавок, строгое неравенство превращается в нестрогое.

---

#### Очерёдность действий в логических выражениях

![alt](/img/and%20%26%26%20or.jpg)

Обработка логических выражений производится в соответствии с законами математической (булевой) логики. 

1. Сначала выполняются действия в круглых скобках.

2. Затем выполняются операции логического отрицания (!)

3. Далее выполняются операции логического И (&&)

4. В последнюю очередь выполняются операции логического ИЛИ (||).

В том случае, если имеется несколько операций одной очерёдности, они исполняются слева направо. Отдельно нужно помнить, что математические операции и операции сравнения производятся ДО логических операций.

Рассмотрим пример:
```
boolean a = true;
boolean b = false;
int c = 30;
int q = 5;

boolean r = (a || b && c >= 25) || (c < 20 * q) && !(q == 5);
```
Как можно видеть, r представляет собой непонятную конструкцию, однако, всё не так плохо, как кажется, если воспользоваться вышеизложенными правилами.

1. Сначала выполняем операции в скобках. Выражений в скобках у нас три, значит, выполним их слева направо.

2. Выражение в первой паре скобок (a || b && c >= 25). Внутри него также несколько операций.

    а) выполняем оперцию сравнения c >= 25. Поскольку c == 30, то это true;

    б) выполняем логическое И: b && c >= 25. b == false, а c >= 25 - это true (см. п. 1а). Следовательно, b && c >= 25 - это false;

    в) выполняем логическое ИЛИ: a == true, b && c >= 25 - это false (см. п. 1б). Следовательно, (a || b && c >= 25) - это true.

Значение в первой паре скобок равно true.

2. Выражение по второй паре скобок (c < 20 * q). 

    а) выполняем арифметическую операцию 20 * q ==100;

    б) выполняем сравнение c < 100 - это true.

Значение во второй паре скобок также true.

3. Выражение в третьей паре скобок (q == 5). Тут всё просто, это true.

Таким образом, обработав значения в скобках, мы преобразовали выражение в более простое:
```
boolean r = true || true && !true;
```
4. Следующие по очереди - операции отрицания. Она одна, выполним её:
```
boolean r = true || true && false;
```
5. Далее выполняем операцию логического И, true && false == false:
```
boolean r = true || false;
```
6. Ну и, наконец, получаем окончательный результат, выполнив последнюю оставшуюся операцию:
```
boolean r = true;
```
На практике следует избегать сложных логических конструкций, так как они очень сильно снижают понятность кода. Вы сами, вернувшись к собственной программе через год, потратите кучу времени для того, чтобы разобраться, как она работает.

---

#### Немного больше о логических конструкциях

Общий список логических операторов в Java более широк, чем те, которые мы рассмотрели. В целом, он соответствует стандартным операциям булевой алгебры (логическое И, логическое ИЛИ, логическое НЕ, исключающее ИЛИ). 

---

#### Вложенные условные конструкции

Довольно часто бывает необходимо вложить одно условие в другое. В языке Java можно вкладывать условные конструкции сколько угодно раз. Например:
```
int age = 25;
if (age > 0) {
    if (age >= 18) {
        System.out.println("Можно сдавать на права");
    } else {
        System.out.println("Ещё рано сдавать на права");
    }
} else {
    System.out.println("Error");
}
```
Следует учитывать, что вложенные условные конструкции тяжелы для управления и чтения кода, поэтому, по возможности, желательно избегать их.

---

Оператор **switch** - Это очень удобная конструкция для выбора каких-либо действий по конкретным флагам. Конструкция проверяет переменную на равенство с определённым заранее списком значений. 

Синтаксис:
```
switch (выражение) {
    case  value1:
        //Группа команд
        break; 

    case value2 :
        //Группа команд
        break; 
    
    ... //Можно вставить столько проверяемых значений, сколько нужно

    default: //Необязательно
       //Группа команд, исполняемая, если значение выражения не рано ни одному из случаев
}
```
Итак, оператор **switch** получает некое выражение,  и вычисляет его значение. Выражением может быть просто переменной или же вычисляемым  Далее идёт перечисление случаев (каждый из которых расположен после слова case), которые ведут к блокам команд, исполняемых в каждом случае. Случаев может быть сколько угодно, но все они вместе должны быть помещены в фигурные скобки. Каждый случай обозначается командой case и двоеточием, после которого идёт блок команд.

Если значение выражения не равно ни одному из случаев, исполняется блок команд, расположенный после слова **default**.

Обратите внимание на важные моменты.

1. Чтобы исполнился определённый блок команд, значение выражения должно быть равно указанному в одном из случаев.

2. Блок команд в каждом случае завершается командой break. Эта команда завершает исполнение всей конструкции switch, и начинается исполнение кода, расположенного после неё. Вообще говоря, команда **break** необязательна, однако её отсутствие приведёт к тому, что выполнится и следующий блок команд.

3. Использование команды **default** также не является обязательным. Тогда, если switch не нашёл соответсвия выражения ни одному из случаев, программа просто перейдёт к исполнению кода, расположенного ниже.

---

#### Блок default

Оператор switch имеет необязательный блок **default**. Команды, расположенные в этом блоке, будут исполнены, если switch не найдёт соответствия аргумента ни с одним из перечисленных case.

```

int day = 2;

switch (day) {
    
    case 1:
        System.out.println("Monday");
        break;

    case 2:
        System.out.println("Tuesday");
        break;

    case 3:
        System.out.println("Wednesday");
        break;

    default:
        System.out.println("Wrong day's number");
}
```
Этот код выведет на печать Tuesday.  Иногда после блока default также добавляют команду break, однако это не нужно, так как этот блок всё равно последний.

---

### 4  Циклы.

#### While

Цикл - это фундаментальная концепция программирования. Циклы позволяют исполнять некоторый блок команд многократно без дублирования кода.

Java предоставляет несколько видов циклических конструкций. Цикл **while** исполняет блок команд (называемый также телом цикла) до тех пор, пока истинно указанное в цикле условие.

Пример:
```
int x = 3;

while (x > 0) {
    System.out.println(x);
    x--;
}
```
1. Вначале необходимо объявить цикл с помощью ключевого слова **while**.

2. Далее в круглых скобках располагается условие выполнения цикла, в нашем примере это (x > 0). Условие должно возвращать логическое значение, то есть, **false** или **true**.

3. Исполняемый циклом блок команд располагается в фигурных скобках. 

4. Внутри фигурных скобок каждая строка, как обычно, обязательно завершается точкой с запятой. После фигурных скобок точка с запятой не нужна. Отступы также не важны с точки зрения кода, однако их соблюдение делает код более удобным и читаемым.

5. Необходимо обязательно предусмотреть условие выхода из цикла, иначе код будет исполняться бесконечно, то есть до переполнения памяти. В нашем примере таким условием является декремент переменной х: с каждой итерацией цикла значение переменной х уменьшается на единицу, и, рано или поздно, оно перестанет удовлетворять условию x > 0.

---

Когда условие цикла становится ложным ( т. е. возвращает false), исполнение цикла прекращается и программа переходит к исполнению первой после цикла строки.
```
int x = 6;

while (x < 10) {
    System.out.println("Цикл исполняется");
    System.out.println("x = " + x);
    x++;
}
System.out.println("Цикл завершён");
System.out.println("x = " + x);

/*
Цикл исполняется
x = 6
Цикл исполняется
x = 7
Цикл исполняется
x = 8
Цикл исполняется
x = 9
Цикл завершён
x = 10
*/
```
Обратите внимание, что последние две строки выведены командами, расположенными уже вне тела цикла.

---

В дополнение к циклу **while** существует также циклическая конструкция **do ... while**. Она отличается от "обычного" цикла лишь тем, что проверка условия происходит не в начале, а в конце тела цикла. Таким образом, тело цикла исполняется, как минимум, один раз.
```
int x = 1;
do {
    System.out.println(x);
    x++;
} while (x < 5);

/*
1
2
3
4
*/
```
Одна итерация гарантированно произойдёт, даже если условие ложно.
```
int x = 1;
do {
    System.out.println(x);
    x++;
} while (x < 0);

// 1
```
Обратите внимание - слово **while** не входит в тело цикла, фигурные скобки закрываются до него. А завершается цикл точкой с запятой после условия.

---

#### Break и continue

Иногда бывает нужно вмешаться в работу цикла и изменить его работу. Для этой цели есть команды break и continue. Команда break немедленно прерывает работу цикла (исполнение программы переходит к командам, расположенным после цикла), а команда continue завершает текущую итерацию (цикл переходит к исполнению следующей итерации).
```
int x = 0;

while (true) {
    x++;
    if (x % 2 == 0) {
        continue;
    } 
    System.out.println(x);
    if (x == 5) {
        break;
    }
}
System.out.println("The end");

/*
1
3
5
The end
*/
```
В приведённом примере, если х является чётным числом, то итерация цикла завершается, то есть, все команды, расположенные в теле цикла, но после команды continue, не исполняются, а цикл переходит к следующей итерации. Если же значение переменной x равно пяти, исполнение цикла принудительно завершается.

---

#### Цикл for.

Если известно точное количество повторений цикла, более удобно использовать другой цикл - **for**. Синтаксис:
```
for (инициализация; условие; счётчик) {
    блок команд;
}
```
**Инициализация**: действие, которое выполняется только один раз в начале работы цикла. Обычно здесь задаётся внутренняя переменная, которая служит счётчиком количества повторений.

**Условие**: логическое выражение, которое вычисляется каждый раз перед итерацией цикла. Если выражение ложно, выполнение цикла прекращается.

**Счётчик**: выражение, которое вычисляется после каждой итерации цикла.

**Блок команд (тело цикла)**: команды, которые исполняются при каждой итерации цикла.

Инициализация, условие и счётчик помещаются в круглые скобки, а разделяются точкой с запятой. Тело цикла помещается в фигурные скобки. Отступы, как обычно, незначащие - но влияющие на читаемость кода.

Следующий код печатает числа от единицы до пяти:
```
for (int i = 1; i <= 5; i++) {
    System.out.println(i);
}
```
Цикл инициализирует внутреннюю переменную i, которой присваивается значение 1. Затем проверяется логическое условие (1 меньше либо равно 5?) и, поскольку условие истинно, выполняется тело цикла, то есть, выводится на печать значение переменной i. Оканчивается итерация выполнением инкремента, то есть значение переменной i становится равным двум. Так цикл работает, пока значение переменной i не превысит 5, после чего цикл прекратит работу. 

Обратите внимание - после окончания работы цикла переменная i исчезает, за пределами фигурных скобок она не существует. 

---

В качестве условий можно использвать любые логические выражения, главное - чтобы условие однозначно определялось, как **true или false**.

Счётчик также может иметь любой шаг или быть отрицательным:
```
for (int i = 5; i < 10; i += 2) {
    System.out.print(i + " "); // 5 7 9
}

for (int i = 5; i > -1; i--) {
    System.out.print(i + " "); // 5 4 3 2 1 0
}

for (int i = 1; i < 10;) {
    System.out.print(i + " "); // Бесконечный цикл
}
```
В последнем случае цикл будет выполняться бесконечно, так как переменная **i** не меняет своё значение, а, значит, никогда не станет больше 10. 

---

kjjlk